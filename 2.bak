package com.peace.framework.dao;

import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import org.apache.log4j.Logger;

import com.peace.framework.util.exception.TaskException;
import com.peace.marketsolution.canonical.Meter;
import com.peace.marketsolution.canonical.Meters;
import com.peace.marketsolution.canonical.Register;
import com.peace.marketsolution.canonical.Registers;
import com.peace.marketsolution.canonical.Service;
import com.peace.marketsolution.canonical.Services;
import com.peace.marketsolution.canonical.Transaction;

/**
 * EnergyDAO is a database access object that allows persistence of data
 * into the table transaction in the energydb schema 
 *
 *
 */
public class EnergyDAO extends AbstractDAO<Transaction> {

	private static final String MKT_SPECIFIC_UNIQUE_SERVICE_ID_NAME = "NMI";

	private static Logger logger = Logger.getLogger(EnergyDAO.class);

    /**
     * Constructor
     */
    public EnergyDAO() {
        super();
    }

    private static final String SELECT_PREMNUM_FROM_UNIQUE_SERVICE_ID =
            " select premnum from ENERGYDB.pm_extref_mktid " +
            "     where ext_sdp_code_upper = ?    " +
            "     and effective_from <= SYSDATE   " +
            "     and (   effective_to IS NULL    " +
            "          or effective_to >= SYSDATE " +
            "     )";

private static final String HHIF_PREMISE_NOTE_PRMADDRDET_SQL =
        "select note_text " +
        " from energydb.nb_note_attach a," +
        "   energydb.nb_note_line b " +
        " where nb_board_id = 'PRMADDRDET' " +
        " and a.nb_note_no = b.nb_note_no " +
        " and a.nb_iref1 = ?";

    private static final String METER_EXTRA_INFO_SQL =
        "select p.ref_no2, r.participant_role, r.ext_sdp_code " +
        "  from energydb.pm_sdp_role r" +
        "      ,energydb.pm_svc_deliv_pt p" +
        "      ,energydb.en_sysdates d " +
        "  where r.sdp_code=p.sdp_code" +
        "    and d.de_date > r.effective_from " +
        "    and ((r.effective_to is null) or (r.effective_to > d.de_date))" +
        "    and p.util_type = 'E'" +
        "    and p.sdp_type = 'M'" +
        "    and p.ref_no1 = ?" +
        "    order by p.ref_no2 ";

    private static final String HHIF_DOG_HAZ_DOWNLOAD_STATUS_SQL =
        " select change_type from energydb.hhif_dog_haz" +
        "   where premnum = ?" +
        "     and dl_notif_date = ?";

    private static final String GET_EXT_SDP_CODE_SQL = "select pm_sdp_role.ext_sdp_code"
        + " from energydb.pm_sdp_role, energydb.pm_svc_deliv_pt, energydb.pm_mkt_party_role, energydb.en_sysdates"
        + " where pm_sdp_role.sdp_code = pm_svc_deliv_pt.sdp_code"
        + " and pm_svc_deliv_pt.sdp_type = 'M'"
        + " and pm_svc_deliv_pt.ref_no1 = ?"
        + " and pm_svc_deliv_pt.ref_no2 = ?"
        + " and pm_svc_deliv_pt.util_type = ?"
        + " and pm_sdp_role.participant_role = pm_mkt_party_role.participant_role"
        + " and pm_mkt_party_role.system_role = 'EXMM'"
        + " and pm_sdp_role.effective_from <= en_sysdates.de_date"
        + " and (pm_sdp_role.effective_to >= en_sysdates.de_date or pm_sdp_role.effective_to is null)"
        + " and (pm_sdp_role.party_util = ? or pm_sdp_role.party_util is null)";

//  private final String COMPLEXSQL2 =
//        "select mm_complex_met_det.*, pm_register.registernum as REGNO               " +
//        "  from energydb.mm_complex_met_det,                                                  " +
//        "       energydb.pm_register                                                          " +
//        " where trim(complex_meter_ref) = trim(?)                                    " +
//        "   and trim(mm_complex_met_det.reg_descr) = trim(pm_register.reg_descr (+)) " +
//        "   and pm_register.premnum (+) = ?                                          " +
//        "   and pm_register.servicenum (+) = ?                                       " +
//        "   and pm_register.util_type (+) = ?                                        " +
//        " order by sequencenum                                                       ";

    private static final String COMPLEX_SQL = "select * from energydb.mm_complex_met_det where " +
        " trim(complex_meter_ref) = trim(?) order by sequencenum" ;

    private static final String GET_NMI_FROM_PREM_SQL = "select pemk.ext_sdp_code nmi " +
        "from   pm_extref_mktid pemk " +
        "where  trim(pemk.participant_role) = 'NMI' " +
        "and    pemk.party_util = 'E' " +
        "and    pemk.premnum = ?";

    private static final String GET_PREM_ROUND_READ_FREQ_SQL = "select read_frequency "+
        "from   energydb.pm_round " +
        "where  roundnum = ?";

    private static final String SYSPARAMSQL =
        "select s.startdate" +
        "      ,s.type_r" +
        "      ,s.code" +
        "      ,s.company_code" +
        "      ,s.amount" +
        "      ,s.period" +
        "      ,s.periodtype" +
        "      ,s.descr" +
        " from energydb.en_sysparam s" +
        "  , energydb.pm_round r" +
        "  , energydb.en_sysdates d" +
        " where  type_r = 'SQ' " +
        " and s.code = ?" +                     //branch code
        " and r.roundnum = ? " +                // Round number
        " and s.code = r.branch_code" +
        " and s.startdate <= d.de_date" +               //survey must be current
        " and (s.startdate + s.period ) >= d.de_date" +
        " and s.amount = r.read_frequency" +    // Amount stores the read frequency
        " order by s.startdate desc";

    private static final String SELECT_REGISTERS_PRIOR_TO_START_DATE =
        " SELECT 1 FROM ENERGYDB.PM_COMMS_METERS pcm   " +
        "   JOIN ENERGYDB.PM_EXTREF_MKTID pem          " +
        "   ON pcm.PREMNUM = pem.PREMNUM               " +
        "   JOIN ENERGYDB.PM_COMMS_REGISTERS pcr       " +
        "   ON pcm.OID = pcr.COMMS_METER_OID           " +
        "   WHERE PARTICIPANT_ROLE = ?                 " +
        "   AND EXT_SDP_CODE = ?                       " +
        "   AND MDM_SUFFIX = ?                         " +
        "   AND ? < REGISTER_START_DATE                " +
        "   AND ? < SYSDATE                            " +
        "   AND REGISTER_STATUS = 'C'                  " +
        "   AND EFFECTIVE_FROM <= SYSDATE              " +
        "   AND (EFFECTIVE_TO IS NULL or EFFECTIVE_TO >= SYSDATE) " ;

    public List<SurveyQuestionDetails> getSurveyQuestionDetails(String branchCode, int roundNumber) throws TaskException{
        while (branchCode.length() < 4) {
            branchCode += " ";
        }

        List<SurveyQuestionDetails> survList = new ArrayList<>();
        try (Connection conn = getEnergyConnection();
                PreparedStatement stmt = conn.prepareStatement(SYSPARAMSQL)) {

            stmt.setString(1, branchCode);
            stmt.setInt(2,roundNumber);

            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()){
                    survList.add(new SurveyQuestionDetails(
                        rs.getDate(1),
                        rs.getString(2),
                        rs.getString(3),
                        rs.getString(4),
                        rs.getDouble(5),
                        rs.getInt(6),
                        rs.getString(7),
                        rs.getString(8)
                    ));
                }
            }

            return survList;
        } catch (SQLException e) {
            logger.error("Unable to find Survey Question Details for " +
                    "given Branch Code  of " + branchCode + " round " + roundNumber
                    ,e );
            throw new TaskException("Caught SQLException ",e);
        }
    }

    public String getNMI(Integer premnum) throws TaskException {
        try (Connection conn = getEnergyConnection();
                PreparedStatement stmt = conn.prepareStatement(GET_NMI_FROM_PREM_SQL)) {

            stmt.setInt(1,premnum.intValue());
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return rs.getString("NMI");
                }

                return null;
            }
        } catch (SQLException e) {
            throw new TaskException("Error in retrieving ext nmi of premnum " + premnum
                + ": " + e);
        }
    }

    public List<ComplexMeterDetails> getComplexMeterDetails(String complexRef) throws TaskException {
        logger.debug("getComplexMeterDetail SQL : " + COMPLEX_SQL);
        logger.debug("complexRef = '" + complexRef + "'");

        List<ComplexMeterDetails> complexList = new ArrayList<>();
        ComplexMeterDetails complexDetail = null;
        try (Connection conn = getEnergyConnection();
                PreparedStatement stmt = conn.prepareStatement(COMPLEX_SQL)) {

            stmt.setString(1, complexRef);

            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()){
                    complexDetail = new ComplexMeterDetails(
                            rs.getString(1).trim(),
                            rs.getInt(2),
                            rs.getInt(3),
                            rs.getInt(4),
                            rs.getString(5),
                            rs.getInt(6),
                            rs.getString(7),
                            rs.getInt(8),
                            rs.getString(9),
                            rs.getString(10),
                            rs.getInt(11),
                            rs.getString(12));

                    complexList.add(complexDetail);
                }
            }
        } catch (SQLException e) {
            throw new TaskException("Unable to find Complex Meter Details for " +
                    "given Complex Ref  of " + complexRef,e );
        }

        return complexList;
    }

//  public List getComplexMeterDetails(int premiseNum, int serviceNum, char utilType) throws TaskException {
//        String complexRef = getComplexMeterReference(premiseNum, serviceNum, utilType);
//        return getComplexMeterDetails(complexRef, premiseNum, serviceNum, utilType);
//    }

//  public List<ComplexMeterDetails> getComplexMeterDetails(String complexRef, int premnum, int servicenum, char utilType) throws TaskException{
//        logger.debug("getComplexMeterDetail SQL : " + COMPLEXSQL2);
//        logger.debug("complexRef = " + complexRef
//            + " premise = " + premnum
//            + " service = " + servicenum
//            + " util type = " + utilType);
//
//        List<ComplexMeterDetails> complexList = new ArrayList<>();
//        ComplexMeterDetails complexDetail;
//        try (Connection conn = getEnergyConnection();
//                PreparedStatement stmt = conn.prepareStatement(COMPLEXSQL2)) {
//            stmt.setString(1, complexRef);
//            stmt.setInt(2, premnum);
//            stmt.setInt(3, servicenum);
//            stmt.setString(4, String.valueOf(utilType));
//
//            try (ResultSet rs = stmt.executeQuery()) {
//                while (rs.next()) {
//                    complexDetail = new ComplexMeterDetails(
//                            rs.getString(1).trim(),
//                            rs.getInt(2),
//                            rs.getInt(3),
//                            rs.getInt(4),
//                            rs.getString(5),
//                            rs.getInt(6),
//                            rs.getString(7),
//                            rs.getInt(8),
//                            rs.getString(9),
//                            rs.getString(10),
//                            rs.getInt(11),
//                            rs.getString(12),
//                            rs.getInt("REGNO"));//pm_register.registernum
//
//                    complexList.add(complexDetail);
//                }
//            }
//        } catch (SQLException e) {
//            throw new TaskException("Unable to find Complex Meter Details for " +
//                    "given Complex Ref  of " + complexRef,e );
//        }
//
//        return complexList;
//    }

    public String getComplexMeterReference(int premiseNum, int serviceNum, char utilType) throws TaskException {
        try (Connection conn = getEnergyConnection();
                PreparedStatement stmt = conn.prepareStatement(GET_EXT_SDP_CODE_SQL)){

            stmt.setInt(1, premiseNum);
            stmt.setInt(2, serviceNum);
            stmt.setString(3, Character.toString(utilType));
            stmt.setString(4, Character.toString(utilType));
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return rs.getString(1);
                }

                return null;
            }
        } catch (SQLException e) {
            throw new TaskException("Unable to get ext sdp code. Premise: " + premiseNum
                + ", serviceNum: " + serviceNum
                + ", utilType: " + utilType
                , e);
        }
    }

    public String getDogHazardDownloadStatus(int premnum, java.util.Date roundListDate) throws TaskException {
        logger.debug("getDogHazardDownloadStatus SQL = " + HHIF_DOG_HAZ_DOWNLOAD_STATUS_SQL
            + ": premnum = " + premnum
            + " round list date: " + roundListDate);

        try (Connection conn = getEnergyConnection();
                PreparedStatement stmt = conn.prepareStatement(HHIF_DOG_HAZ_DOWNLOAD_STATUS_SQL)) {

            stmt.setInt(1, premnum);
            stmt.setDate(2, new java.sql.Date(roundListDate.getTime()));
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()){
                    return rs.getString(1);
                }

                return null;
            }
        } catch (SQLException e) {
            throw new TaskException("Unable to determine dog hazard update status. Premise: " + premnum + " round list date: " + roundListDate, e);
        }
    }

    public List<ExtraMeterInfo> getExtraMeterInfo(int premnum) throws TaskException {
        logger.debug("getExtraMeterInfo SQL = " + METER_EXTRA_INFO_SQL + ": premnum = " + premnum);

        List<ExtraMeterInfo> extraMeterInfoList = new ArrayList<>();
        try (Connection conn = getEnergyConnection();
                PreparedStatement stmt = conn.prepareStatement(METER_EXTRA_INFO_SQL)) {

            stmt.setInt(1, premnum);
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()){
                    ExtraMeterInfo extraMeterInfo = new ExtraMeterInfo();
                    extraMeterInfo.serviceNumber = rs.getInt("ref_no2");
                    extraMeterInfo.participantRole = rs.getString("participant_role");
                    extraMeterInfo.externalReference = rs.getString("ext_sdp_code");

                extraMeterInfoList.add(extraMeterInfo);
                }
            }
        } catch (SQLException e) {
            throw new TaskException("Unable to find extra meter info for premise " + premnum, e);
        }

        return extraMeterInfoList;
    }

    public String getAddressPremiseNote(int premnum) throws TaskException{
        logger.debug("getAddressPremiseNote SQL = " + HHIF_PREMISE_NOTE_PRMADDRDET_SQL
            + ": premnum = " + premnum);

        try (Connection conn = getEnergyConnection();
                PreparedStatement stmt = conn.prepareStatement(HHIF_PREMISE_NOTE_PRMADDRDET_SQL)){

            stmt.setInt(1, premnum);
            try(ResultSet rs = stmt.executeQuery()) {
                while (rs.next()){
                    return rs.getString(1);
                }

                return null;
            }
        } catch (SQLException e) {
            throw new TaskException("Unable to find address info premise note. Premise: " + premnum + e);
        }
    }

    public Integer getPremnumFromUniqueServiceId(String uniqueServiceId) throws TaskException {

        Connection conn        = null;
        PreparedStatement stmt = null;
        ResultSet rs           = null;
        Integer premnum        = -1;

        try {
            conn = getEnergyConnection();
            stmt = conn.prepareStatement(SELECT_PREMNUM_FROM_UNIQUE_SERVICE_ID);
            stmt.setString(1, uniqueServiceId);

            rs = stmt.executeQuery();

            while (rs.next()) {
                premnum = rs.getInt(1);
            }
        } catch (SQLException e) {
            throw new TaskException("Unable to create a prepared statement when setting the unique service identifier on the query", e);
        } finally {
            closeConnection(conn, stmt, rs);
        }

        return premnum;
    }

    @Override
    protected Transaction readNext(ResultSet rs) throws TaskException {
        return null;
    }

    private static final String SELECT_MIT_FROM_PREMNUM =
            "SELECT distinct(participant_code) FROM PM_SDP_ROLE WHERE sdp_code in " +
            " (SELECT sdp_code FROM PM_SVC_DELIV_PT WHERE ref_no1 = ? AND sdp_type = 'M' " +
                " AND ref_no2 = (SELECT min(servicenum) from eb_meter_install WHERE premnum = ? AND " +
                " status_meter ='C')" +
            " ) " +
            " AND participant_role = 'MIT'" +
            " AND effective_to is null";

    public String getMeterInstallationTypeFromPremnum(Integer premnum) throws TaskException{

        Connection conn              = null;
        PreparedStatement stmt       = null;
        ResultSet rs                 = null;
        String meterInstallationType = null;

        try {
            conn = getEnergyConnection();
            stmt = conn.prepareStatement(SELECT_MIT_FROM_PREMNUM);
            stmt.setInt(1, premnum);
            stmt.setInt(2, premnum);

            rs = stmt.executeQuery();

            while (rs.next()) {
                meterInstallationType = rs.getString(1);
            }
        } catch (SQLException e) {
            throw new TaskException("Unable to create a prepared statement when setting the premnum on the query", e);
        } finally {
            closeConnection(conn, stmt, rs);
        }

        return meterInstallationType;
    }

    private static final String SELECT_NMI_CLASSIFICATION_FROM_PREMNUM =
            "select participant_code  " +
            "   from pm_sdp_role r, pm_svc_deliv_pt s " +
            "   where s.ref_no1 = ? " +
            "   and s.sdp_type = 'P' " +
            "   and s.sdp_code = r.sdp_code " +
            "   and r.participant_role = 'CLAS' " +
            "   and (SYSDATE <= r.effective_to  " +
            "   or r.effective_to is null)  " +
            "   and r.effective_from <= SYSDATE";

    public String getnmiClassificationTypeFromPremnum(Integer premnum) throws TaskException{

        Connection conn              = null;
        PreparedStatement stmt       = null;
        ResultSet rs                 = null;
        String nmiClassification     = null;

        try {
            conn = getEnergyConnection();
            stmt = conn.prepareStatement(SELECT_NMI_CLASSIFICATION_FROM_PREMNUM);
            stmt.setInt(1, premnum);

            rs = stmt.executeQuery();

            while (rs.next()) {
                nmiClassification = rs.getString(1);
            }
        } catch (SQLException e) {
            throw new TaskException("Unable to create a prepared statement when setting the premnum on the query", e);
        } finally {
            closeConnection(conn, stmt, rs);
        }

        return nmiClassification;
    }

    private static final String SELECT_IS_UNIQUE_SERVICE_ID_EXIST2 =
        " select 1 from ENERGYDB.pm_extref_mktid " +
        "   where ext_sdp_code_upper = ?         " +
        "   and trim(participant_role) = ?       " +
        "   and effective_from <= SYSDATE        " +
        "   and (   effective_to IS NULL         " +
        "        or effective_to >= SYSDATE      " +
        "   )";

    public boolean isUniqueServiceIdentifierExist(String uniqueServiceId) throws TaskException {
        Connection conn        = null;
        PreparedStatement stmt = null;
        ResultSet rs           = null;
        boolean result         = false;

        try {
            conn = getEnergyConnection();
            stmt = conn.prepareStatement(SELECT_IS_UNIQUE_SERVICE_ID_EXIST2);
            stmt.setString(1, uniqueServiceId);
            stmt.setString(2, MKT_SPECIFIC_UNIQUE_SERVICE_ID_NAME);
            rs = stmt.executeQuery();
            result = rs.next();
        } catch (SQLException e) {
            throw new TaskException("Unable to create a prepared statement when setting the unique service identifier on the query", e);
        } finally {
            closeConnection(conn, stmt, rs);
        }
        return result;
    }

    private static final String SELECT_IS_UNIQUE_SERVICE_ID_EXIST =
            " select 1 from ENERGYDB.pm_extref_mktid " +
            "   where ext_sdp_code_upper = ?         " +
            "   and trim(participant_role) = ?       " +
            "   and effective_from <= ?              " +
            "   and (   effective_to IS NULL         " +
            "        or effective_to >= SYSDATE      " +
            "   )";

    public boolean isUniqueServiceIdExist(Transaction transaction) throws TaskException {

        Connection conn        = null;
        PreparedStatement stmt = null;
        ResultSet rs           = null;
        boolean result         = false;

        String uniqueServiceId = transaction.getTransactionData().getUniqueServiceIdentifier();
        long readingStartTime = transaction.getServices().getServiceArray(0).getServiceStartDateTime().getTime().getTime();

        try {
            conn = getEnergyConnection();
            stmt = conn.prepareStatement(SELECT_IS_UNIQUE_SERVICE_ID_EXIST);
            stmt.setString(1, uniqueServiceId);
            stmt.setString(2, MKT_SPECIFIC_UNIQUE_SERVICE_ID_NAME);
            stmt.setDate(3, new java.sql.Date (readingStartTime));
            rs = stmt.executeQuery();
            result = rs.next();
        } catch (SQLException e) {
            throw new TaskException("Unable to create a prepared statement when setting the unique service id on the query", e);
        } finally {
            closeConnection(conn, stmt, rs);
        }
        return result;
    }

    private static final String SELECT_IS_METER_EXIST2 =
        " select 1 from ENERGYDB.pm_extref_mktid e" +
        "   JOIN ENERGYDB.pm_comms_meters c      " +
        "   on e.premnum = c.premnum             " +
        "   where ext_sdp_code_upper = ?         " +
        "   and trim(participant_role) = ?       " +
        "   and effective_from <= SYSDATE        " +
        "   and (   effective_to IS NULL         " +
        "        or effective_to >= SYSDATE      " +
        "   )";

    public Boolean isMeterExist(String uniqueServiceId) throws TaskException {
        Connection conn        = null;
        PreparedStatement stmt = null;
        ResultSet rs           = null;
        boolean result         = false;

        try {
            conn = getEnergyConnection();
            stmt = conn.prepareStatement(SELECT_IS_METER_EXIST2);
            stmt.setString(1, uniqueServiceId);
            stmt.setString(2, MKT_SPECIFIC_UNIQUE_SERVICE_ID_NAME);
            rs = stmt.executeQuery();
            result = rs.next();
        } catch (SQLException e) {
            throw new TaskException("Unable to create a prepared statement when setting the unique service identifier on the query", e);
        } finally {
            closeConnection(conn, stmt, rs);
        }
        return result;
    }

    private static final String SELECT_IS_METER_EXIST =
            " select 1 FROM energydb.PM_COMMS_METERS meter  " +
            " JOIN ENERGYDB.PM_EXTREF_MKTID mkt             " +
            "   ON mkt.PREMNUM = meter.PREMNUM              " +
            "   AND PARTICIPANT_ROLE = ?                    " +
            "   AND EXT_SDP_CODE = ?                        " +
            "   AND EFFECTIVE_FROM <= ?                     " +
            "   AND (EFFECTIVE_TO IS NULL OR EFFECTIVE_TO >= SYSDATE)" +
            "   AND INITIAL_INSTALL_DATE <= ?               " +
            "   AND (removal_date IS NULL or removal_date >= ?) " +
            " JOIN energydb.PM_COMMS_METERS_INFO info       " +
            "   ON meter.oid = info.COMMS_METER_OID         " +
            "   AND ACTUAL_CHANGE_DATE <= ?                 " +
            "   AND (ACTUAL_END_DATE IS NULL OR ACTUAL_END_DATE >= ?) " ;

    public boolean isMeterExist(Transaction transaction) throws TaskException {

        Connection conn        = null;
        PreparedStatement stmt = null;
        ResultSet rs           = null;
        boolean result         = false;

        String uniqueServiceId = transaction.getTransactionData().getUniqueServiceIdentifier();
        long readingStartTime = transaction.getServices().getServiceArray(0).getServiceStartDateTime().getTime().getTime();
        long readingEndTime = transaction.getServices().getServiceArray(0).getServiceEndDateTime().getTime().getTime();
        try {
            conn = getEnergyConnection();
            stmt = conn.prepareStatement(SELECT_IS_METER_EXIST);
            stmt.setString(1, MKT_SPECIFIC_UNIQUE_SERVICE_ID_NAME);
            stmt.setString(2, uniqueServiceId);
            stmt.setDate(3, new java.sql.Date (readingStartTime));
            stmt.setDate(4, new java.sql.Date (readingStartTime));
            stmt.setDate(5, new java.sql.Date (readingEndTime));
            stmt.setDate(6, new java.sql.Date (readingStartTime));
            stmt.setDate(7, new java.sql.Date (readingEndTime));

            rs = stmt.executeQuery();
            result = rs.next();
        } catch (SQLException e) {
            throw new TaskException("Unable to create a prepared statement when setting the unique service identifier on the query", e);
        } finally {
            closeConnection(conn, stmt, rs);
        }
        return result;
    }

    private static final String SELECT_REGISTER_SUFFIXES =
            " SELECT DISTINCT REGISTER_ID               " +
            " FROM ENERGYDB.PM_COMMS_METERS meter       " +
            " JOIN ENERGYDB.PM_EXTREF_MKTID mkt         " +
            "   ON meter.PREMNUM = mkt.PREMNUM          " +
            "   AND PARTICIPANT_ROLE = ?                " +
            "   AND EXT_SDP_CODE = ?                    " +
            "   AND EFFECTIVE_FROM <= ?                 " +
            "   AND (EFFECTIVE_TO IS NULL OR EFFECTIVE_TO >= SYSDATE)" +
            "   AND INITIAL_INSTALL_DATE <= ?           " +
            "   AND (removal_date IS NULL or removal_date >= ?)" +
            " JOIN ENERGYDB.PM_COMMS_REGISTERS reg      " +
            "   ON meter.OID = reg.COMMS_METER_OID      " +
            "   AND (REGISTER_END_DATE IS NULL OR REGISTER_END_DATE >= ?) " ;

    public boolean isRegistersValid(Transaction transaction) throws TaskException {

        Connection conn        = null;
        PreparedStatement stmt = null;
        ResultSet rs           = null;

        String uniqueServiceId = transaction.getTransactionData().getUniqueServiceIdentifier();
        long readingStartTime = transaction.getServices().getServiceArray(0).getServiceStartDateTime().getTime().getTime();
        long readingEndTime = transaction.getServices().getServiceArray(0).getServiceEndDateTime().getTime().getTime();

        try {
            List<String> registerSuffixesFromFile = transaction.getServices().getServiceList().stream()
                    .flatMap(service -> service.getMeters().getMeterList().stream())
                    .flatMap(meter -> meter.getRegisters().getRegisterList().stream())
                    .map(Register::getRegisterSuffix)
                    .collect(Collectors.toList());

            if (logger.isDebugEnabled()) {
                logger.debug("Registers in MV90 file: " + registerSuffixesFromFile);
            }

            if(registerSuffixesFromFile.isEmpty()) {
                return false;
            }

            List<String> registerSuffixesFromQuery = new ArrayList<>();
            conn = getEnergyConnection();
            stmt = conn.prepareStatement(SELECT_REGISTER_SUFFIXES);
            stmt.setString(1, MKT_SPECIFIC_UNIQUE_SERVICE_ID_NAME);
            stmt.setString(2, uniqueServiceId);
            stmt.setDate(3, new java.sql.Date (readingStartTime));
            stmt.setDate(4, new java.sql.Date (readingStartTime));
            stmt.setDate(5, new java.sql.Date (readingEndTime));
            stmt.setDate(6, new java.sql.Date (readingEndTime));

            rs = stmt.executeQuery();
            while (rs.next()){
                registerSuffixesFromQuery.add(rs.getString(1));
            }

            return registerSuffixesFromQuery.containsAll(registerSuffixesFromFile);

        } catch (SQLException e) {
            throw new TaskException("Unable to create a prepared statement when setting parameters on the query", e);
        } finally {
            closeConnection(conn, stmt, rs);
        }
    }

    private static final String SELECT_IS_REGISTER_EXIST =
        " SELECT 1 FROM ENERGYDB.PM_COMMS_METERS pcm   " +
        "   JOIN ENERGYDB.PM_EXTREF_MKTID pem          " +
        "   ON pcm.PREMNUM = pem.PREMNUM               " +
        "   JOIN ENERGYDB.PM_COMMS_REGISTERS pcr       " +
        "   ON pcm.OID = pcr.COMMS_METER_OID           " +
        "   WHERE PARTICIPANT_ROLE = ?                 " +
        "   AND EXT_SDP_CODE = ?                       " +
        "   AND MDM_SUFFIX = ?                         " +
        "   AND EFFECTIVE_FROM <= SYSDATE              " +
        "   AND (EFFECTIVE_TO IS NULL or EFFECTIVE_TO >= SYSDATE) " ;

    public Boolean isAllRegistersValid(Transaction transaction) throws TaskException {
        Connection conn        = null;
        PreparedStatement stmt = null;
        ResultSet rs           = null;

        String uniqueServiceIdentifier = transaction.getTransactionData().getUniqueServiceIdentifier();

        try {
            conn = getEnergyConnection();

            Services services = transaction.getServices();
            for(Service service : services.getServiceList()) {
                Meters meters = service.getMeters();
                for(Meter meter : meters.getMeterList()) {
                    Registers registers = meter.getRegisters();
                    for(Register register : registers.getRegisterList()) {
                        stmt = conn.prepareStatement(SELECT_IS_REGISTER_EXIST);
                        stmt.setString(1, MKT_SPECIFIC_UNIQUE_SERVICE_ID_NAME);
                        stmt.setString(2, uniqueServiceIdentifier);
                        stmt.setString(3, register.getRegisterSuffix());
                        rs = stmt.executeQuery();
                        if(!rs.next()) {
                            return false;
                        }
                    }
                }
            }
        } catch (SQLException e) {
            throw new TaskException("Unable to create a prepared statement when setting parameters on the query", e);
        } finally {
            closeConnection(conn, stmt, rs);
        }

        return true;
    }

    private static final String SELECT_IS_REGISTER_STANDING_DATA_MATCH =
            " SELECT 1 FROM ENERGYDB.PM_COMMS_METERS meter " +
            " JOIN ENERGYDB.PM_EXTREF_MKTID mkt            " +
            "   ON meter.PREMNUM = mkt.PREMNUM             " +
            "   AND PARTICIPANT_ROLE = ?                   " +
            "   AND EXT_SDP_CODE = ?                       " +
            "   AND EFFECTIVE_FROM <= ?                    " +
            "   AND (EFFECTIVE_TO IS NULL or EFFECTIVE_TO >= SYSDATE) " +
            "   AND INITIAL_INSTALL_DATE <= ?              " +
            "   AND (removal_date IS NULL or removal_date >= ?)" +
            " JOIN ENERGYDB.PM_COMMS_REGISTERS reg         " +
            "   ON meter.OID = reg.COMMS_METER_OID         " +
            "   AND REGISTER_ID = ?                        " +
            "   AND MDM_SUFFIX = ?                         " +
            "   AND reg.MULTIPLIER = ?                     " +
            "   AND UNIT_OF_MEASURE = ?                    " +
            "   AND (REGISTER_END_DATE IS NULL OR REGISTER_END_DATE >= ?) " ;

    public boolean isStandingDataMatch(Transaction transaction) throws TaskException {

        Connection conn        = null;
        PreparedStatement stmt = null;
        ResultSet rs           = null;

        String uniqueServiceId = transaction.getTransactionData().getUniqueServiceIdentifier();
        try {
            conn = getEnergyConnection();

            Services services = transaction.getServices();
            for(Service service : services.getServiceList()) {
                Meters meters = service.getMeters();
                for(Meter meter : meters.getMeterList()) {
                    Registers registers = meter.getRegisters();
                    for(Register register : registers.getRegisterList()) {
                        long readingStartTime = register.getServiceStartDateTime().getTime().getTime();
                        long readingEndTime = register.getServiceEndDateTime().getTime().getTime();
                        stmt = conn.prepareStatement(SELECT_IS_REGISTER_STANDING_DATA_MATCH);
                        stmt.setString(1, MKT_SPECIFIC_UNIQUE_SERVICE_ID_NAME);
                        stmt.setString(2, uniqueServiceId);
                        stmt.setDate(3, new Date(readingStartTime));
                        stmt.setDate(4, new java.sql.Date (readingStartTime));
                        stmt.setDate(5, new java.sql.Date (readingEndTime));
                        stmt.setString(6, register.getRegisterSuffix());
                        stmt.setString(7, register.getRegisterSuffix());
                        stmt.setBigDecimal(8, register.getMultiplier());
                        stmt.setString(9, register.getUnitOfMeasureCode());
                        stmt.setDate(10, new java.sql.Date (readingEndTime));
                        rs = stmt.executeQuery();
                        if(!rs.next()) {
                            return false;
                        }
                    }
                }
            }
        } catch (SQLException e) {
            throw new TaskException("Unable to create a prepared statement when setting parameters on the query", e);
        } finally {
            closeConnection(conn, stmt, rs);
        }
        return true;
    }

    private static final String SELECT_IS_REGISTER_PRIOR_TO_START_DATE =
            " select 1 FROM energydb.PM_COMMS_METERS meter  " +
            " JOIN ENERGYDB.PM_EXTREF_MKTID pem             " +
            "   ON pem.PREMNUM = meter.PREMNUM              " +
            "   AND PARTICIPANT_ROLE = ?                    " +
            "   AND EXT_SDP_CODE = ?                        " +
            "   AND EFFECTIVE_FROM <= ?                     " +
            "   AND (EFFECTIVE_TO IS NULL or EFFECTIVE_TO >= SYSDATE) " +
            "   AND INITIAL_INSTALL_DATE <= ?               " +
            "   AND (removal_date IS NULL or removal_date >= ?)" +
            " JOIN energydb.PM_COMMS_REGISTERS reg          " +
            "   ON meter.oid = reg.COMMS_METER_OID          " +
            "   AND REGISTER_ID = ?                         " +
            "   AND ? < reg.REGISTER_START_DATE             " ;

    public boolean isReadingsStartDateValid(Transaction transaction) throws TaskException {

        Connection conn        = null;
        PreparedStatement stmt = null;
        ResultSet rs           = null;

        String uniqueServiceId = transaction.getTransactionData().getUniqueServiceIdentifier();

        try {
            conn = getEnergyConnection();

            Services services = transaction.getServices();
            for(Service service : services.getServiceList()) {
                Meters meters = service.getMeters();
                for(Meter meter : meters.getMeterList()) {
                    Registers registers = meter.getRegisters();
                    for(Register register : registers.getRegisterList()) {
                        long readingStartTime = register.getServiceStartDateTime().getTime().getTime();
                        long readingEndTime = register.getServiceEndDateTime().getTime().getTime();
                        stmt = conn.prepareStatement(SELECT_IS_REGISTER_PRIOR_TO_START_DATE);
                        stmt.setString(1, MKT_SPECIFIC_UNIQUE_SERVICE_ID_NAME);
                        stmt.setString(2, uniqueServiceId);
                        stmt.setDate(3, new Date(readingStartTime));
                        stmt.setDate(4, new java.sql.Date (readingStartTime));
                        stmt.setDate(5, new java.sql.Date (readingEndTime));
                        stmt.setString(6, register.getRegisterSuffix());
                        stmt.setDate(7, new Date(readingStartTime));
                        rs = stmt.executeQuery();
                        if(rs.next()) {
                            return false;
                        }
                    }
                }
            }
        } catch (SQLException e) {
            throw new TaskException("Unable to create a prepared statement when setting parameters on the query", e);
        } finally {
            closeConnection(conn, stmt, rs);
        }
        return true;
    }

    private static final String SELECT_IS_REGISTER_INTERVAL_LENGTH_MATCH =
            " select 1 FROM energydb.PM_COMMS_METERS meter  " +
            " JOIN ENERGYDB.PM_EXTREF_MKTID pem             " +
            "   ON pem.PREMNUM = meter.PREMNUM              " +
            "   AND PARTICIPANT_ROLE = ?                    " +
            "   AND EXT_SDP_CODE = ?                        " +
            "   AND EFFECTIVE_FROM <= ?                     " +
            "   AND (EFFECTIVE_TO IS NULL or EFFECTIVE_TO >= SYSDATE) " +
            "   AND INITIAL_INSTALL_DATE <= ?               " +
            "   AND (removal_date IS NULL or removal_date >= ?)" +
            " JOIN energydb.PM_COMMS_REGISTERS reg          " +
            "   ON meter.OID = reg.COMMS_METER_OID          " +
            "   AND REGISTER_ID = ?                         " +
            "   AND REGISTER_START_DATE <= ?                " +
            "   AND (REGISTER_END_DATE IS NULL OR REGISTER_END_DATE >= ?) " +
            " JOIN ENERGYDB.PM_COMMS_INTERVAL_LENGTH length " +
            "   ON meter.OID = length.COMMS_METER_OID       " +
            "   AND INTERVAL_LENGTH = ?                     " +
            "   AND length.START_DATE >= REGISTER_START_DATE" ;

    public boolean isIntervalLengthMatch(Transaction transaction) throws TaskException {

        Connection conn        = null;
        PreparedStatement stmt = null;
        ResultSet rs           = null;

        String uniqueServiceId = transaction.getTransactionData().getUniqueServiceIdentifier();

        try {
            conn = getEnergyConnection();

            Services services = transaction.getServices();
            for(Service service : services.getServiceList()) {
                Meters meters = service.getMeters();
                for(Meter meter : meters.getMeterList()) {
                    Registers registers = meter.getRegisters();
                    for(Register register : registers.getRegisterList()) {
                        long readingStartTime = register.getServiceStartDateTime().getTime().getTime();
                        long readingEndTime = register.getServiceEndDateTime().getTime().getTime();
                        stmt = conn.prepareStatement(SELECT_IS_REGISTER_INTERVAL_LENGTH_MATCH);
                        stmt.setString(1, MKT_SPECIFIC_UNIQUE_SERVICE_ID_NAME);
                        stmt.setString(2, uniqueServiceId);
                        stmt.setDate(3, new Date (readingStartTime));
                        stmt.setDate(4, new Date (readingStartTime));
                        stmt.setDate(5, new Date (readingEndTime));
                        stmt.setString(6, register.getRegisterSuffix());
                        stmt.setDate(7, new Date (readingStartTime));
                        stmt.setDate(8, new Date (readingEndTime));
                        stmt.setString(9, register.getIntervalLength());
                        rs = stmt.executeQuery();
                        if(!rs.next()) {
                            return false;
                        }
                    }
                }
            }
        } catch (SQLException e) {
            throw new TaskException("Unable to create a prepared statement when setting parameters on the query", e);
        } finally {
            closeConnection(conn, stmt, rs);
        }
        return true;
    }

    public Boolean isFirstReadingsValid(Transaction transaction) throws TaskException {
        Connection conn        = null;
        PreparedStatement stmt = null;
        ResultSet rs           = null;

        String uniqueServiceIdentifier = transaction.getTransactionData().getUniqueServiceIdentifier();

        try {
            conn = getEnergyConnection();

            Services services = transaction.getServices();
            for(Service service : services.getServiceList()) {
                Meters meters = service.getMeters();
                for(Meter meter : meters.getMeterList()) {
                    Registers registers = meter.getRegisters();
                    for(Register register : registers.getRegisterList()) {
                        java.sql.Date firstReadingDate = new java.sql.Date(register.getServiceStartDateTime().getTime().getTime());
                        stmt = conn.prepareStatement(SELECT_REGISTERS_PRIOR_TO_START_DATE);
                        stmt.setString(1, MKT_SPECIFIC_UNIQUE_SERVICE_ID_NAME);
                        stmt.setString(2, uniqueServiceIdentifier);
                        stmt.setString(3, register.getRegisterSuffix());
                        stmt.setDate(4, firstReadingDate);
                        stmt.setDate(5, firstReadingDate);
                        rs = stmt.executeQuery();
                        if(rs.next()) {
                            return false;
                        }
                    }
                }
            }
        } catch (SQLException e) {
            throw new TaskException("Unable to create a prepared statement when setting parameters on the query", e);
        } finally {
            closeConnection(conn, stmt, rs);
        }

        return true;
    }

    public Integer getReadFreq(Integer roundNum) throws TaskException {
        try (Connection conn = getEnergyConnection();
                PreparedStatement stmt = conn.prepareStatement(GET_PREM_ROUND_READ_FREQ_SQL)) {

            stmt.setInt(1, roundNum.intValue());
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return Integer.valueOf(rs.getInt("READ_FREQUENCY"));
                }

                return null;
            }
        } catch (SQLException e) {
            throw new TaskException("Error in retrieving round frequency information from PM_ROUND " + roundNum
                + ": " + e);
        }
    }

}
